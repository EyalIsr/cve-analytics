import toml
import ibis

import streamlit as st
import plotly.express as px

from dotenv import load_dotenv
from datetime import datetime, timedelta

# options
## load .env
load_dotenv()

## config.toml
config = toml.load("config.toml")["app"]

## streamlit config
st.set_page_config(layout="wide")

## ibis config
con = ibis.duckdb.connect(f"{config['database']}", read_only=True)

with open("readme.md") as f:
    readme_code = f.read()

f"""
{readme_code}


"""

def fmt_number(value):
    return f"{value:,}"

def fmt_float(value):
    return f"{value:.2f}"

def delta(current, previous, fmt_fnc=fmt_number):
    delta = current - previous
    pct_change = int(round(100.0 * delta / previous, 0))
    return f"{fmt_fnc(delta)} ({pct_change:d}%)"


vulnerabilities = con.table("vulnerabilities_and_categories")

# variables
with st.form(key="app"):
    days = st.number_input(
        "X days",
        min_value=1,
        max_value=120,
        value=30,
        step=30,
        format="%d",
    )
    update_button = st.form_submit_button(label="update")


START = datetime.now() - timedelta(days=days * 2)
STOP = datetime.now() - timedelta(days=days)

total_vul, total_vul_prev = (
    vulnerabilities.agg(
        total_vul=vulnerabilities.id.nunique(where=vulnerabilities.published >= STOP),
        total_vul_prev=vulnerabilities.id.nunique(
            where=vulnerabilities.published.between(START, STOP)
        ),
    )
    .to_pandas()
    .squeeze()
)


mean_score = vulnerabilities.filter(vulnerabilities.published >= STOP).distinct(on="id").primary_score.mean().to_pandas()
mean_score_prev=vulnerabilities.filter(vulnerabilities.published.between(START, STOP)).distinct(on="id").primary_score.mean().to_pandas()

total_exploited, total_exploited_prev = (
    vulnerabilities.agg(
    total_exploited=vulnerabilities.id.nunique(where=(vulnerabilities.published >= STOP) & (vulnerabilities.cisaExploitAdd.notnull())),
    total_exploited_prev=vulnerabilities.id.nunique(
        where=(vulnerabilities.published.between(START, STOP)) & (vulnerabilities.cisaExploitAdd.notnull())
    ),
    )
    .to_pandas()
    .squeeze()
)

f"""
## totals (last {days} days)
"""
col1, col2, col3, col4, col5 = st.columns(5)
with col1:
    st.metric(
        label="Total Vulnerabilities",
        value=fmt_number(total_vul),
        delta=delta(total_vul, total_vul_prev),
    )

with col2:
    st.metric(
        label="Average vulnerabilities score",
        value=fmt_float(mean_score),
        delta=delta(mean_score, mean_score_prev, fmt_fnc=fmt_float)
    )

with col3:
    st.metric(
        label="Total exploited",
        value=fmt_number(total_exploited),
        delta=delta(total_exploited, total_exploited_prev),
    )
# viz
c0 = px.line(
    vulnerabilities.filter(ibis._.published > datetime.now() - timedelta(days=days)).order_by(
        ibis._.published.desc()
    ),
    x="published",
    y="total_vulns",
    title="cumulative vulnerabilities",
)
st.plotly_chart(c0, use_container_width=True)

st.dataframe(
    vulnerabilities.filter(ibis._.published > datetime.now() - timedelta(days=days))
        .fill_null({"name":"UN-CATEGORIZED"})
        .group_by("name")
        .agg(ibis._.count().name("weakness_category_total"))
        .order_by(ibis._.weakness_category_total.desc()), 
    use_container_width=True,
)

c1 = px.bar(
    vulnerabilities.group_by([ibis._.published.truncate("M").name("published_month"), ibis._.primary_severity])
    .agg(vulns=lambda t: t.count(where=t.published > STOP))
    .order_by(ibis._.published),
    x="published_month",
    y="vulns",
    color="primary_severity",
    title="vulnerabilities monthly",
)
st.plotly_chart(c1, use_container_width=True)
